[{"name":"app.R","content":"library(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(mvtnorm)\nlibrary(MASS)\nlibrary(shinythemes)\nlibrary(plotly)\nlibrary(ggforce)\nlibrary(gganimate)\nlibrary(ellipse)\nlibrary(av)\nlibrary(gifski)\n\nif (FALSE) library(munsell)\n\nui <- navbarPage(\"Bonferroni, Simultaneous, Ellipses Visualized\",\n                 theme = shinytheme(\"flatly\"),\n                 \n                 tabPanel(\"Main\",\n                          helpText(\"Samples, and shows the Simultaneous (T²) Intervals, Confidence Ellipse, and Bonferroni Intervals and coverage probabilities\"),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                sliderInput(\"sample_size\", \"Sample Size:\", value = 30, min = 10, max = 1000, step = 10),\n                                h4(\"Mean Vector (μ):\"),\n                                textInput(\"mu\", \"μ (e.g., 0, 0):\", value = \"0, 0\"),\n                                \n                                h4(\"Covariance Matrix (Σ):\"),\n                                textInput(\"sigma\", \"Σ (row-wise, e.g., 1, 0, 0, 1):\", value = \"1, 0, 0, 1\"),\n                                \n                                helpText(\"Insert values with a , as the delimiter\"),\n                                helpText(HTML(\"\n                                  <b>Legend:<\/b><br>\n                                  <span style='color:black;'>■ Confidence Ellipse<\/span><br>\n                                  <span style='color:skyblue;'>— T² Simultaneous Intervals<\/span><br>\n                                  <span style='color:darkblue;'>-- Bonferroni Intervals<\/span><br>\n                                  <span style='color:black;'>● Sample Mean<\/span><br>\n                                  <span style='color:blue;'>✱ True Mean<\/span>\n                                \")),\n                                br(), \n                                helpText(\n                                  \"Use the tools at the top to move around the plot\"\n                                ),\n                                \n                                sliderInput(\"confidence\", \"Confidence Level:\", value = 0.95, min = 0.90, max = 0.99, step = 0.01),\n                                \n                                actionButton(\"resample\", \"Generate New Sample\", class = \"btn-primary\"),\n                                \n                                hr(),\n                                \n                                h4(\"Coverage Probabilities:\"),\n                                tableOutput(\"coverage_table\")\n                              ),\n                              mainPanel(\n                                plotlyOutput(\"distPlot\", height = \"800px\"),\n                                hr(),\n                                h4(\"Interval Comparisons:\"),\n                                tableOutput(\"interval_table\"),\n                                fluidRow(\n                                  column(12,\n                                         h4(\"Interpretation\"),\n                                         textOutput(\"interpretation1\")\n                                  )\n                                ),\n                                br(),\n                                br(),\n                                br()\n                              )\n                            )\n                          )\n                 ),\n                 tabPanel(\"Coverage Probability (ellipses)\",\n                          withMathJax(\n                            helpText(\"$$\n                              \\\\text{Population distribution: } \n                              N \\\\left( \n                                \\\\begin{bmatrix}\n                                  2 \\\\\\\\\n                                  5\n                                \\\\end{bmatrix}, \n                                \\\\begin{bmatrix}\n                                  3 & 1 \\\\\\\\\n                                  1 & 4\n                                \\\\end{bmatrix}\n                              \\\\right)\n                            $$\")\n                          ),\n                          helpText(\"Drawing 20 ellipses, with a sample size n = 30\"),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                sliderInput(\"confidence_tab2\", \"Confidence Level:\", value = 0.95, min = 0.90, max = 0.99, step = 0.01),\n                                actionButton(\"generate\", \"Generate Ellipses\"),\n                                helpText(\"Press the button to keep resampling (might take some time to load animation)\")\n                            \n                              ),\n                              mainPanel(\n                                fluidRow(\n                                  column(6, \n                                         plotOutput(\"ellipsePlot\", height = \"600px\")\n                                  ),\n                                  column(6,\n                                         imageOutput(\"ellipseGIF\", width = \"100%\", height = \"auto\")\n                                  )\n                                ),\n                                verbatimTextOutput(\"coverageCount\"), \n                                fluidRow(\n                                  column(12,\n                                         h4(\"Interpretation\"),\n                                         textOutput(\"interpretation2\")\n                                  )\n                                ),\n                                br(),\n                                br(),\n                                br()\n                            )\n                          )\n                      )\n                 ),\n                 tabPanel(\"Coverage Probabilities (Bonferroni)\",\n                          withMathJax(\n                            helpText(\"$$\n                              \\\\text{Population distribution: } \n                              N \\\\left( \n                                \\\\begin{bmatrix}\n                                  2 \\\\\\\\\n                                  5\n                                \\\\end{bmatrix}, \n                                \\\\begin{bmatrix}\n                                  3 & 1 \\\\\\\\\n                                  1 & 4\n                                \\\\end{bmatrix}\n                              \\\\right)\n                            $$\")\n                          ),\n                          helpText(\"Drawing 20 intervals, with a sample size of n = 30\"),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                sliderInput(\"confidence_tab3\", \"Confidence Level:\", value = 0.95, min = 0.90, max = 0.99, step = 0.01),\n                                actionButton(\"generate2\", \"Generate Intervals\"),\n                                helpText(\"Press the button to keep resampling (might take some time to load animation)\")\n                                \n                              ),\n                              mainPanel(\n                                fluidRow(\n                                  column(6, \n                                         plotOutput(\"intervalPlot\", height = \"600px\")\n                                  ),\n                                  column(6,\n                                         imageOutput(\"intervalGIF\", width = \"100%\", height = \"auto\")\n                                  )\n                                ),\n                                verbatimTextOutput(\"coverageCount2\"),\n                                fluidRow(\n                                  column(12,\n                                         h4(\"Interpretation\"),\n                                         textOutput(\"interpretation3\")\n                                  )\n                                ),\n                                br(),\n                                br(),\n                                br()\n                              )\n                            )\n                          )\n                   \n                 ),\n                 tabPanel(\"Coverage Probabilities (T^2)\",\n                          withMathJax(\n                            helpText(\"$$\n                              \\\\text{Population distribution: } \n                              N \\\\left( \n                                \\\\begin{bmatrix}\n                                  2 \\\\\\\\\n                                  5\n                                \\\\end{bmatrix}, \n                                \\\\begin{bmatrix}\n                                  3 & 1 \\\\\\\\\n                                  1 & 4\n                                \\\\end{bmatrix}\n                              \\\\right)\n                            $$\")\n                          ),\n                          helpText(\"Drawing 20 intervals, with a sample size of n = 30\"),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                sliderInput(\"confidence_tab4\", \"Confidence Level:\", value = 0.95, min = 0.90, max = 0.99, step = 0.01),\n                                actionButton(\"generate3\", \"Generate Intervals\"),\n                                helpText(\"Press the button to keep resampling (might take some time to load animation)\")\n                                \n                              ),\n                              mainPanel(\n                                fluidRow(\n                                  column(6, \n                                         plotOutput(\"intervalPlot2\", height = \"600px\")\n                                  ),\n                                  column(6,\n                                         imageOutput(\"intervalGIF2\", width = \"100%\", height = \"auto\")\n                                  )\n                                ),\n                                verbatimTextOutput(\"coverageCount3\"),\n                                fluidRow(\n                                  column(12,\n                                         h4(\"Interpretation\"),\n                                         textOutput(\"interpretation4\")\n                                  )\n                                ),\n                                br(),\n                                br(),\n                                br()\n                              )\n                            )\n                          )\n                          \n                 ),\n                 footer = tags$footer(\n                   style = \"\n                      position: fixed;\n                      bottom: 0;\n                      left: 0;\n                      width: 100%;\n                      background-color: #f8f9fa;\n                      border-top: 1px solid #ddd;\n                      text-align: center;\n                      padding: 8px;\n                      font-size: 12px;\n                      color: #6c757d;\n                      z-index: 1000;\n                    \",\n                   \"2025 Created by Shahriar Shams and Issey Sone\"\n                 )\n)\n\nserver <- function(input, output, session) {\n  \n  \n  output$bottom_progress <- renderUI({NULL})\n\n  \n  \n  ranges <- reactiveValues(x = NULL, y = NULL)\n  \n  observeEvent(event_data(\"plotly_relayout\", source = \"distPlot\"), {\n    ed <- event_data(\"plotly_relayout\", source = \"distPlot\")\n    \n    if (!is.null(ed[[\"xaxis.range[0]\"]]) && !is.null(ed[[\"xaxis.range[1]\"]])) {\n      ranges$x <- c(ed[[\"xaxis.range[0]\"]], ed[[\"xaxis.range[1]\"]])\n    }\n    \n    if (!is.null(ed[[\"yaxis.range[0]\"]]) && !is.null(ed[[\"yaxis.range[1]\"]])) {\n      ranges$y <- c(ed[[\"yaxis.range[0]\"]], ed[[\"yaxis.range[1]\"]])\n    }\n  })\n  \n  parseMatrix <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 4 || any(is.na(vals))) return(NULL)\n    matrix(vals, nrow = 2, byrow = TRUE)\n  }\n  \n  parseVector <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 2 || any(is.na(vals))) return(NULL)\n    vals\n  }\n  \n  mu <- reactive({\n    result <- parseVector(input$mu)\n    if (is.null(result)) c(0, 0) else result\n  })\n  \n  sigma <- reactive({\n    result <- parseMatrix(input$sigma)\n    if (is.null(result)) matrix(c(1, 0, 0, 1), nrow = 2) else result\n  })\n  \n  sample_data <- reactiveVal(NULL)\n  \n  observe({\n    if (is.null(sample_data())) {\n      set.seed(123)\n      data <- mvrnorm(n = input$sample_size, mu = mu(), Sigma = sigma())\n      sample_data(data)\n    }\n  })\n  \n  observeEvent(c(input$resample, input$sample_size, input$mu, input$sigma), {\n    data <- mvrnorm(n = input$sample_size, mu = mu(), Sigma = sigma())\n    sample_data(data)\n  })\n  \n  stats <- reactive({\n    data <- sample_data()\n    if (is.null(data)) return(NULL)\n    \n    n <- nrow(data)\n    p <- ncol(data)\n    xbar <- colMeans(data)\n    S <- cov(data)\n    \n    alpha <- 1 - input$confidence\n    \n    t2_crit <- ((n-1) * p / (n-p)) * qf(input$confidence, p, n-p)\n    \n    bonf_crit <- qt(1 - alpha/(2*p), n-1)\n    \n    se <- sqrt(diag(S) / n)\n    \n    list(\n      n = n, p = p, xbar = xbar, S = S, se = se,\n      t2_crit = t2_crit, bonf_crit = bonf_crit,\n      alpha = alpha\n    )\n  })\n  \n  output$distPlot <- renderPlotly({\n    req(sample_data(), stats())\n    \n    alpha <- 1 - input$confidence_tab2\n    \n    data <- sample_data()\n    s <- stats()\n    \n    df <- data.frame(X1 = data[,1], X2 = data[,2])\n    \n    t2_half_width <- sqrt(s$t2_crit * s$se^2)\n    bonf_half_width <- s$bonf_crit * s$se\n    \n    t2_x_lower <- s$xbar[1] - t2_half_width[1]\n    t2_x_upper <- s$xbar[1] + t2_half_width[1]\n    t2_y_lower <- s$xbar[2] - t2_half_width[2]\n    t2_y_upper <- s$xbar[2] + t2_half_width[2]\n    \n    bonf_x_lower <- s$xbar[1] - bonf_half_width[1]\n    bonf_x_upper <- s$xbar[1] + bonf_half_width[1]\n    bonf_y_lower <- s$xbar[2] - bonf_half_width[2]\n    bonf_y_upper <- s$xbar[2] + bonf_half_width[2]\n    \n    x_range <- c(t2_x_lower, t2_x_upper)\n    y_range <- c(t2_y_lower, t2_y_upper)\n    x_extend <- diff(x_range) * 0.15\n    y_extend <- diff(y_range) * 0.15\n    \n    ellipse_data <- ellipse(s$S/s$n, centre = s$xbar, \n                            level = input$confidence, npoints = 100)\n    ellipse_df <- data.frame(X1 = ellipse_data[,1], X2 = ellipse_data[,2])\n    \n    default_xmin = x_range[1] - x_extend\n    default_xmax = x_range[2] + x_extend\n    \n    default_ymin = y_range[1] - y_extend\n    default_ymax = y_range[2] + y_extend\n    p1 <- ggplot(df, aes(x = X1, y = X2)) +\n      coord_cartesian(\n        xlim = if (!is.null(ranges$x)) ranges$x else c(default_xmin, default_xmax),\n        ylim = if (!is.null(ranges$y)) ranges$y else c(default_ymin, default_ymax)\n      ) + \n      theme_minimal() +\n      theme(\n        panel.grid.minor = element_blank(),\n        axis.title = element_text(size = 12),\n        plot.title = element_text(size = 14)\n      ) +\n      labs(title = paste(\"Confidence Regions Comparison (n =\", s$n, \")\"),\n           subtitle = paste(\"Confidence Level:\", 100*input$confidence, \"%\"),\n           x = \"μ₁\",\n           y = \"μ₂\")\n    \n    p1 <- p1 + \n      geom_path(data = ellipse_df, aes(x = X1, y = X2), \n                color = \"black\", size = 1.2, linetype = \"solid\")\n    \n    p1 <- p1 + \n      geom_vline(xintercept = t2_x_lower, color = \"skyblue\", size = 1.2, linetype = \"solid\") +\n      geom_vline(xintercept = t2_x_upper, color = \"skyblue\", size = 1.2, linetype = \"solid\")\n    \n    p1 <- p1 + \n      geom_hline(yintercept = t2_y_lower, color = \"skyblue\", size = 1.2, linetype = \"solid\") +\n      geom_hline(yintercept = t2_y_upper, color = \"skyblue\", size = 1.2, linetype = \"solid\")\n    \n    p1 <- p1 + \n      geom_vline(xintercept = bonf_x_lower, color = \"darkblue\", size = 1, linetype = \"dashed\") +\n      geom_vline(xintercept = bonf_x_upper, color = \"darkblue\", size = 1, linetype = \"dashed\") +\n      geom_hline(yintercept = bonf_y_lower, color = \"darkblue\", size = 1, linetype = \"dashed\") +\n      geom_hline(yintercept = bonf_y_upper, color = \"darkblue\", size = 1, linetype = \"dashed\")\n    \n    p1 <- p1 + \n      geom_point(aes(x = s$xbar[1], y = s$xbar[2]), \n                 color = \"black\", size = 3, shape = 19)\n    \n    true_mu <- mu()\n    p1 <- p1 + \n      geom_point(aes(x = true_mu[1], y = true_mu[2]), \n                 color = \"blue\", size = 3, shape = 8)\n    \n    legend_x <- x_range[1] + diff(x_range) * 0.02\n    legend_y_start <- y_range[2] - diff(y_range) * 0.05\n    legend_spacing <- diff(y_range) * 0.08\n    \n    ggplotly(p1, source = \"distPlot\")\n  })\n  \n  # Intervals comparison table\n  output$interval_table <- renderTable({\n    req(stats())\n    s <- stats()\n    \n    t2_half_width <- sqrt(s$t2_crit * s$se^2)\n    bonf_half_width <- s$bonf_crit * s$se\n    \n    intervals_df <- data.frame(\n      Method = rep(c(\"T² Simultaneous\", \"Bonferroni\"), each = 2),\n      Variable = rep(c(\"X₁\", \"X₂\"), 2),\n      Lower = c(s$xbar - t2_half_width, s$xbar - bonf_half_width),\n      Upper = c(s$xbar + t2_half_width, s$xbar + bonf_half_width),\n      Width = c(2 * t2_half_width, 2 * bonf_half_width)\n    )\n    \n    intervals_df$Lower <- round(intervals_df$Lower, 3)\n    intervals_df$Upper <- round(intervals_df$Upper, 3)\n    intervals_df$Width <- round(intervals_df$Width, 3)\n    \n    intervals_df\n  }, striped = TRUE, hover = TRUE)\n  \n  output$coverage_table <- renderTable({\n    req(stats())\n    \n    set.seed(42)\n    n_sim <- 1000\n    coverage_results <- replicate(n_sim, {\n\n      n <- input$sample_size\n      sim_data <- mvrnorm(n, mu = mu(), Sigma = sigma())\n      sim_xbar <- colMeans(sim_data)\n      sim_S <- cov(sim_data)\n      sim_se <- sqrt(diag(sim_S) / input$sample_size)\n      p <- length(mu())\n      \n\n      alpha <- 1 - input$confidence\n      t2_crit <- ((n-1) * p / (n-p)) * qf(input$confidence, p, n-p)\n      bonf_crit <- qt(1 - alpha/(2*p), n-1)\n      \n      t2_half_width <- sqrt(t2_crit * sim_se^2)\n      bonf_half_width <- bonf_crit * sim_se\n      \n      true_mu <- mu()\n      t2_covers <- all(abs(sim_xbar - true_mu) <= t2_half_width)\n      bonf_covers <- all(abs(sim_xbar - true_mu) <= bonf_half_width)\n      \n      t2_stat <-  as.numeric(input$sample_size * t(sim_xbar - true_mu) %*% solve(sim_S) %*% (sim_xbar - true_mu))\n      ellipse_covers <- t2_stat <= t2_crit\n      \n      c(ellipse_covers, t2_covers, bonf_covers)\n    })\n    \n    coverage_probs <- rowMeans(coverage_results)\n    \n    data.frame(\n      Method = c(\"Confidence Ellipse\", \"T² Simultaneous\", \"Bonferroni\"),\n      `Theoretical Coverage` = rep(input$confidence, 3),\n      `Simulated Coverage` = round(coverage_probs, 3),\n      `Difference` = round(coverage_probs - input$confidence, 3),\n      check.names = FALSE\n    )\n  }, striped = TRUE, hover = TRUE)\n  \n  generate_ellipse_points <- function(x0, y0, a, b, angle_deg, n_points = 100) {\n    theta <- seq(0, 2 * pi, length.out = n_points)\n    angle_rad <- angle_deg * pi/ 100\n    \n    x_std <- a * cos(theta)\n    y_std <- b * sin(theta)\n    \n    x <- x0 + x_std * cos(angle_rad) - y_std * sin(angle_rad)\n    y <- y0 + x_std * sin(angle_rad) + y_std * cos(angle_rad)\n    \n    return (data.frame(x = x, y = y))\n  }\n  # Tab 2\n  \n  ellipse_gif_path <- reactiveVal(NULL)\n  \n  observeEvent(input$generate, {\n    n <- 100\n    num <- 20\n    true_mu <- c(2, 5)\n    alpha <- 1 - input$confidence_tab2\n    true_Sigma <- matrix(c(3, 1, 1, 4), nrow = 2)\n    ellipses <- list()\n    coverage <- logical(num)\n    \n    \n    for (i in 1:num) {\n      sample_data <- mvrnorm(n = n, mu = true_mu, Sigma = true_Sigma)\n      xbar <- colMeans(sample_data)\n      S <- cov(sample_data)\n      eig <- eigen(S/n)\n      \n      radius <- sqrt(qchisq(1 - alpha, df = 2))\n      mdist2 <- mahalanobis(true_mu, center = xbar, cov = S/n)\n      covered = ifelse(mdist2 <= qchisq(1 - alpha, 2), \"Covered\", \"Missed\")\n      \n      ellipse_points <- generate_ellipse_points(\n        x0 = xbar[1],\n        y0 = xbar[2],\n        a = radius * sqrt(eigen(S/n)$values[1]),\n        b = radius * sqrt(eigen(S/n)$values[2]),\n        angle = atan2(eig$vectors[2, 1], eig$vectors[1, 1]) * 180 / pi\n      )\n      \n      ellipse_points$id <- i\n      ellipse_points$covered <- covered\n      coverage[i] = ifelse(covered == \"Covered\", TRUE, FALSE)\n      ellipse_points$frame <- i\n      ellipses[[i]] <- ellipse_points\n    }\n    \n\n    \n    ellipse_df <- do.call(rbind, ellipses)\n    \n    p <-  ggplot(ellipse_df) +\n      geom_point(aes(x = true_mu[1], y = true_mu[2]), color = \"darkblue\", size = 4, shape = 4) +\n      annotate(\"text\", x = true_mu[1] + 0.1, y = true_mu[2] + 0.1, \n               label = \"True Mean\", color = \"darkblue\", hjust = 0, size = 4) + \n      geom_path(aes(x = x, y = y, group = id, color = covered),\n                   alpha = 1) +\n      scale_color_manual(values = c(\"Covered\" = \"skyblue\", \"Missed\" = \"orange\")) +\n      coord_fixed() +\n      labs(title = \"Confidence Ellipses and True Mean\",\n           x = \"X1\", y = \"X2\", color = \"Coverage\") +\n      theme_minimal()\n    \n    output$ellipsePlot <- renderPlot({\n      p\n    })\n    \n    panim <- p + \n      transition_states(frame, transition_length = 2, state_length = 20) +\n      shadow_mark(past = TRUE, alpha = 0.2)\n\n    anim <- animate(panim, nframes = num, res = 120, fps = 5, render = gifski_renderer())\n    gif_path <- file.path(tempdir(), \"ellipse_animation.gif\")\n    anim_save(gif_path, animation = anim)\n    ellipse_gif_path(gif_path)\n    \n    output$ellipseGIF <- renderImage({\n      list(src = gif_path,\n           contentType = 'image/gif',\n           width = 550, \n           height = 600,\n           alt = 'Ellipse Animation')\n    }, deleteFile = FALSE)\n    \n    output$coverageCount <- renderText({\n      paste(sum(coverage), \"out of\", num, \"ellipses contain the true mean.\")\n    })\n  })\n  # session$onSessionEnded(function() {\n  #   for (path in c(ellipse_gif_path(), bonf_gif_path(), t2_gif_path())) {\n  #     if (!is.null(path) && file.exists(path)) {\n  #       file.remove(path)\n  #     }\n  #   }\n  # })\n  \n  bonf_gif_path <- reactiveVal(NULL)\n  t2_gif_path   <- reactiveVal(NULL)\n  \n  # tab 3\n  observeEvent(input$generate2, {\n    num <- 20\n    n <- 30\n    p <- 2\n    alpha <- 1 - input$confidence_tab3\n    true_mu <- c(2, 5)\n    true_Sigma <- matrix(c(3, 1, 1, 4), nrow = 2)\n    bonf_data <- data.frame()\n    coverage <- logical(num)\n    for (i in 1:num) {\n      sample_data <- mvrnorm(n, mu = true_mu, Sigma = true_Sigma)\n      xbar <- colMeans(sample_data)\n      S <- cov(sample_data)\n      se <- sqrt(diag(S) / n)\n\n      tval <- qt(1 - alpha/(2*p), n - 1)\n\n      lower <- xbar - tval * se\n      upper <- xbar + tval * se\n      cover_x1 <- lower[1] <= true_mu[1] && true_mu[1] <= upper[1]\n      cover_x2 <- lower[2] <= true_mu[2] && true_mu[2] <= upper[2]\n      coverage[i] <- cover_x1 & cover_x2\n      bonf_data <- rbind(bonf_data,\n        data.frame(\n          Sample = i,\n          Variable = \"X1\",\n          Est = xbar[1],\n          Lower = lower[1],\n          Upper = upper[1],\n          Missed = !cover_x1,\n          Frame = i\n        ),\n        data.frame(\n          Sample = i,\n          Variable = \"X2\",\n          Est = xbar[2],\n          Lower = lower[2],\n          Upper = upper[2],\n          Missed = !cover_x2,\n          Frame = i\n        )\n      )\n    }\n    bonf_data$Missed <- factor(bonf_data$Missed, levels = c(TRUE, FALSE), labels = c(\"Missed\", \"Covered\"))\n    \n    p <- ggplot(bonf_data, aes(x = Sample, y = Est, color = Missed)) +\n      geom_point(size = 2) +\n      geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.2) +\n      facet_wrap(~Variable, ncol = 1) + \n      geom_hline(data = data.frame(Variable = c(\"X1\", \"X2\"), \n                                   mu = true_mu), \n                 aes(yintercept = mu), color = \"black\", linetype = \"dashed\") +\n      scale_color_manual(values = c(\"Covered\" = \"skyblue\", \"Missed\" = \"orange\")) +\n      labs(title = \"Bonferroni Intervals for Means\",\n           x = \"Sample\",\n           y = \"CI\", color = \"Coverage\") +\n      theme_minimal() +\n      theme(strip.text = element_text(size = 14),\n            plot.title = element_text(hjust = 0.5))\n\n    output$intervalPlot <- renderPlot({\n     p\n    })\n    \n    panim_bonf <- p + transition_states(Frame, transition_length = 1, state_length = 1) + \n      shadow_mark(past = TRUE, alpha = 0.3)\n    anim_bonf <- animate(panim_bonf, nframes = n, fps = 5, res = 120, width = 500, height = 600)\n    gif_bonf_path <- file.path(tempdir(), \"bonferroni_animation.gif\")\n    \n    bonf_gif_path(gif_bonf_path)\n    anim_save(gif_bonf_path, animation = anim_bonf)\n    \n    output$intervalGIF <- renderImage({\n      list(src = gif_bonf_path,\n           contentType = 'image/gif',\n           width = 500,\n           height = 600,\n           alt = 'Bonferroni Animation')\n    }, deleteFile = FALSE)\n    \n    output$coverageCount2 <- renderText({\n      paste(sum(coverage), \"out of\", num, \"Bonferroni intervals contain the true mean.\")\n    })\n  })\n  \n  \n  observeEvent(input$generate3, {\n    num <- 20\n    n <- 30\n    p <- 2 \n    alpha <- 1 - input$confidence_tab4\n\n    true_mu <- c(2, 5)\n    true_Sigma <- matrix(c(3, 1, 1, 4), nrow = 2)\n    t2_data <- data.frame()\n    coverage <- logical(num) \n\n    for (i in 1:num) {\n      sample_data <- mvrnorm(n, mu = true_mu, Sigma = true_Sigma)\n      xbar <- colMeans(sample_data)\n      S <- cov(sample_data)\n      se <- sqrt(diag(S) / n)\n\n      f_crit <- (p * (n - 1) / (n - p)) * qf(1 - alpha, df1 = p, df2 = n - p)\n      me <- sqrt(f_crit * se^2)\n\n      lower <- xbar - me\n      upper <- xbar + me\n\n      cover_x1 <- lower[1] <= true_mu[1] && true_mu[1] <= upper[1]\n      cover_x2 <- lower[2] <= true_mu[2] && true_mu[2] <= upper[2]\n      coverage[i] <- cover_x1 && cover_x2\n\n      t2_data <- rbind(\n        t2_data,\n        data.frame(Sample = i, Variable = \"X1\", Est = xbar[1], Lower = lower[1], Upper = upper[1], Missed = !cover_x1, Frame = i),\n        data.frame(Sample = i, Variable = \"X2\", Est = xbar[2], Lower = lower[2], Upper = upper[2], Missed = !cover_x2, Frame = i)\n      )\n    }\n\n    t2_data$Missed <- factor(t2_data$Missed, levels = c(TRUE, FALSE), labels = c(\"Missed\", \"Covered\"))\n\n    p <- ggplot(t2_data, aes(x = Sample, y = Est, color = Missed)) +\n      geom_point(size = 2) +\n      geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.2) +\n      facet_wrap(~Variable, ncol = 1) + \n      geom_hline(data = data.frame(Variable = c(\"X1\", \"X2\"), \n                                   mu = true_mu), \n                 aes(yintercept = mu), color = \"black\", linetype = \"dashed\") +\n      scale_color_manual(values = c(\"Covered\" = \"skyblue\", \"Missed\" = \"orange\")) +\n      labs(title = \"T² Simultaneous Intervals for Means\",\n           x = \"Sample\",\n           y = \"CI\", color = \"Coverage\") +\n      theme_minimal() +\n      theme(strip.text = element_text(size = 14),\n            plot.title = element_text(hjust = 0.5))\n    output$intervalPlot2 <- renderPlot({\n      p\n    })\n    panim_t2 <- p + transition_states(Frame, transition_length = 1, state_length = 1) + \n      shadow_mark(past = TRUE, alpha = 0.3)\n    anim_t2 <- animate(panim_t2, nframes = n, fps = 5, res = 120, width = 500, height = 600)\n    gif_t2_path <- file.path(tempdir(), \"t2_animation.gif\")\n    anim_save(gif_t2_path, animation = anim_t2)\n    \n    t2_gif_path(gif_t2_path)\n    \n    output$intervalGIF2 <- renderImage({\n      list(src = gif_t2_path,\n           contentType = 'image/gif',\n           width = 500,\n           height = 600,\n           alt = 'T² Animation')\n    }, deleteFile = FALSE)\n    output$coverageCount3 <- renderText({\n      paste(sum(coverage), \"out of\", num, \"T² intervals contain the true mean.\")\n    })\n    \n    # Interpretations\n    \n  })\n  output$interpretation1 <- renderText({\n    \"Increasing the sample size will make the ellipse and intervals narrower and closer together. If you zoom out of the plot, and keep generating new samples\n      you will notice some intervals may not capture the true mean. Increasing the confidence level will make the ellipses/intervals wider as well.\"\n  })\n  \n  output$interpretation2 <- renderText({\n    conf_level <- input$confidence_tab2 * 100\n    paste0(\n    \"Just like generating confidence intervals in the univariate case, not every sample-based confidence ellipse will contain the true mean. If we keep drawing samples an infinite amount of times,\n    the \", round(conf_level, 1),  \"% confidence ellipse will cover the true mean \", round(conf_level, 1), \"% of the time.\")\n  })\n  \n  output$interpretation3 <- renderText({\n    conf_level <- input$confidence_tab3 * 100\n    paste0(\n    \"Bonferroni intervals are narrower than T^2 ones. When drawing an infinite amount of samples, about \", round(conf_level, 1), \"% of the constructed Bonferroni intervals for each variable\n    will individually contain their true means. However, the joint probability that both intervals simultaneously cover the true means is slightly less than \", round(conf_level, 1), \"%.\")\n  })\n  output$interpretation4 <- renderText({\n    conf_level <- input$confidence_tab4 * 100\n    paste0(\n    \"Simultaneous (T^2) Intervals are wider than the Bonferroni ones and are more likely to cover the true mean. These intervals are constructed so that if we sample\n    an infinite amount of times, approximately \", round(conf_level, 1), \"% of the ellipses will jointly enclose the true mean vector. Unlike Bonferroni, this method explicity controls the\n    overall coverage probability for both variables at once.\")\n  })\n}\n\nshinyApp(ui = ui, server = server)","type":"text"}]
