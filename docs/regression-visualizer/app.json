[{"name":"app.R","content":"library(shiny)\nlibrary(shinythemes)\nlibrary(MASS)\nlibrary(tidyverse)\nlibrary(plotly)\nlibrary(gridExtra)\nlibrary(ellipse)\nlibrary(DT)\n\n\nif (FALSE) library(munsell)\n\nui <- navbarPage(\"Regression\",\n                 theme = shinytheme(\"flatly\"),\n                 tabPanel(\"Univariate Regression\",\n                          withMathJax(\n                            helpText(\n                              \"$$\\\\begin{bmatrix}\n                                  \\\\hat\\\\beta_0 \\\\\\\\\n                                  \\\\hat\\\\beta_1\n                                  \\\\end{bmatrix}\n                                  \n                                  \\\\sim N_2(\\\\begin{bmatrix} \\\\beta_0 \\\\\\\\ \\\\beta_1 \\\\end{bmatrix}, \\\\sigma^2\\\\begin{bmatrix}\n                                   \\\\frac{1}{n} + \\\\frac{\\\\bar x }{S_{xx}} & -\\\\frac{\\\\bar x}{S_{xx}}  \\\\\\\\\n                                   -\\\\frac{\\\\bar x}{S_{xx}} & \\\\frac{1}{S_{xx}} \n                                  \\\\end{bmatrix})$$\"\n                            )\n                          ),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                numericInput(\"n_draws\", \"Number of Observations (sample size):\", value = 10, min = 100, max = 10000, step = 100),\n                                h4(\"Beta Vector (β):\"),\n                                textInput(\"betas\", \"β (eg. Beta0, Beta1): \", value = \"3, 0.5\"),\n                                helpText(\"For best results, keep Beta0 between -10 to 12 and Beta1 between -1 to 2\"),\n                                \n                                h4(\"sigma squared\"),\n                                numericInput(\"sigmasq\", \"σ^2: \", value = 3),\n                        \n                              \n                                actionButton(\"run_simulation\", \"Run Simulation\", class = \"btn-primary\"),\n                                \n                                h4(\"Expected Properties\"),\n                                verbatimTextOutput(\"theoretical_info\"),\n                                withMathJax(\n                                helpText(\"$$\\\\epsilon_i \\\\sim N(0, σ^2) \\\\\\\\ S_{xx} = \\\\sum(x_i - \\\\bar x)^2$$\")\n                                ),\n                                helpText(HTML(\"\n                                  <b>Legend:<\/b><br>\n                                  <span style='color:red;'>-- True Beta value<\/span><br>\n                                  <span style='color:blue;'>— Empirical Beta value<\/span><br>\n                                  <span style='color:black;'>-- Underlying distribution<\/span><br>\n                                \"))\n                              ),\n                              \n                              mainPanel(\n                                plotlyOutput(\"bivariate_plot\"),\n                                plotOutput(\"marginal_plots\"),\n                                fluidRow(\n                                  column(12,\n                                         h4(\"Interpretation\"),\n                                         textOutput(\"interpretation_uni\")\n                                  )\n                                ),\n                                br(),\n                                br(),\n                                br()\n                              )\n                            )\n                          )\n                 ),\n                 tabPanel(\"Multivariate Regression\",\n                          withMathJax(\n                            helpText(\n                              \"$$\\\\mathbf{y} = \\\\mathbf{X}\\\\boldsymbol{\\\\beta} + \\\\boldsymbol{\\\\epsilon}, \\\\quad \\\\boldsymbol{\\\\epsilon} \\\\sim N(\\\\mathbf{0}, \\\\Sigma)$$\"\n                            )\n                          ),\n                          fluidPage(\n                            sidebarLayout(\n                              sidebarPanel(\n                                numericInput(\"n_draws_mvt\", \"Number of Observations (sample size):\", value = 10, min = 100, max = 5000, step = 100),\n                                \n                                h4(\"Regression Parameters:\"),\n                                textInput(\"betas_mv\", \"β (β01, β11, β02, β12): \", value = \"3, 0.5, 5, 1.5\"),\n                                textInput(\"sigmasq_mv\", \"Σ Variance of epsilon: \", value = \"2, 0, 0, 5\"),\n                                helpText(\"has to be positive definite\"),\n                                \n                                withMathJax(\n                                  helpText(\n                                    \"$$Y_{j1} = \\\\beta_{01} + \\\\beta_{11}z_{j1} + \\\\epsilon_{j1} \\\\\\\\\n                                       Y_{j1} = \\\\beta_{02} + \\\\beta_{12}z_{j2} + \\\\epsilon_{j2}$$\"\n                                  )\n                                ), \n                                \n                                \n                                actionButton(\"run_simulation_mv\", \"Run Simulation\", class = \"btn-primary\"),\n                                \n                                h4(\"Expected Covariance Matrix\"),\n                                verbatimTextOutput(\"cov_matrix_display\"),\n                                helpText(HTML(\"\n                                  <b>Legend:<\/b><br>\n                                  <span style='color:red;'>-- True Beta value<\/span><br>\n                                  <span style='color:blue;'>— Empirical Beta value<\/span><br>\n                                  <span style='color:black;'>-- Underlying distribution<\/span><br>\n                                \"))\n                              ),\n                              \n                              mainPanel(\n                                tabsetPanel(\n                                  tabPanel(\"Joint Distribution\", \n                                           plotlyOutput(\"multivariate_joint_plot1\"),\n                                           br(),\n                                           plotlyOutput(\"multivariate_joint_plot2\"),\n                                           br(),\n                                           br(),\n                                           br()\n                                  ),\n                                  tabPanel(\"Marginal Distributions\",\n                                           plotOutput(\"multivariate_marginal_plots\")\n                                  ),\n                                  tabPanel(\"Simulation Summary\",\n                                           h4(\"Coefficient Estimates Summary:\"),\n                                           DT::dataTableOutput(\"summary_table\"),\n                                           br(),\n                                           h4(\"Expected vs. Empirical Comparison:\"),\n                                           verbatimTextOutput(\"comparison_output\"),\n                                           fluidRow(\n                                             column(12,\n                                                    h4(\"Interpretation\"),\n                                                    textOutput(\"interpretation_mv\"),\n                                                    withMathJax(\n                                                      helpText(\n                                                        \"$$\\\\Sigma \\\\sim \\\\begin{bmatrix}\n                                                          \\\\sigma_{1} & \\\\sigma_{12} \\\\\\\\\n                                                          \\\\sigma_{12} & \\\\sigma_{2}\n                                                        \\\\end{bmatrix} \\\\text{then } \\\\text{Cov}(\\\\hat{\\\\beta^{(1)}}, \\\\hat{\\\\beta^{(2)}}) = \\\\sigma_{12}(X^TX)^{-1}$$\"\n                                                        \n                                                      )\n                                                    )\n                                             )\n                                           ),\n                                           br(),\n                                           br(),\n                                           br()\n                                           \n                                  ) \n                                )\n                              )\n                            )\n                          )\n                 ),\n                 tabPanel(\"Prediction Ellipse\",\n                  withMathJax(\n                    helpText(\n                      \"$$\\\\text{T}^2\\\\text{ Simultaneous Prediction Intervals: }\n                      \n                        \\\\hat{Y}(x_0)_j \\\\pm \\\\sqrt{c \\\\cdot \\\\hat{\\\\sigma}_{jj} (1 + \\\\mathbf{x}_0^T (\\\\mathbf{X}^T\\\\mathbf{X})^{-1} \\\\mathbf{x}_0)}\n                       \\\\text{ where } c = \\\\frac{p(n - 1)}{n - p} F_{p, n - p}(1 - \\\\alpha)$$\n                       $$\\\\text{Prediction Ellipse: } \\\\hat{Y}(x_0) \\\\pm t_{\\\\alpha/2, n-2} \\\\sqrt{\\\\hat{\\\\sigma}^2 (1 + \\\\mathbf{x}_0^T(\\\\mathbf{X}^T\\\\mathbf{X})^{-1}\\\\mathbf{x}_0)}$$\"\n                    )\n                  ),\n                  fluidPage(\n                    sidebarLayout(\n                      sidebarPanel(\n                        h4(\"Data Generation Parameters: \"),\n                        numericInput(\"n_pred\", \"Sample Size:\", value = 10, min = 10, max = 200, step= 10),\n                        textInput(\"betas_mv_pred\", \"β (β01, β11, β02, β12): \", value = \"3, 0.5, 5, 1.5\"),\n                        textInput(\"sigmasq_mv_pred\", \"Σ Variance of epsilon: \", value = \"2, 0, 0, 5\"),\n                        helpText(\"has to be positive definite\"),\n                        \n                        h4(\"Prediction Settings: \"),\n                        numericInput(\"x_new\", \"New X value for prediction: \", value = 10),\n                        sliderInput(\"conf_level\", \"Confidence Level: \", value = 0.95, min = 0.9, max = 0.99, step = 0.01),\n                        \n                        actionButton(\"generate_pred_data\", \"Generate Data & Predict\", class = \"btn-primary\"),\n                        \n                        br(),\n                        h4(\"Prediction Results\"),\n                        verbatimTextOutput(\"prediction_results\"),\n                        br(),\n                        helpText(HTML(\"\n                                  <b>Legend:<\/b><br>\n                                  <span style='color:blue;'>- Prediction Interval<\/span><br>\n                                  <span style='color:red;'>● Predicted point<\/span><br>\n                                  <span style='color:skyblue;'>— T^2 interval<\/span><br>\n                                \")\n                      )\n                      ),\n                      mainPanel(\n                        plotlyOutput(\"prediction_plot\"),\n                        fluidRow(\n                          column(12,\n                                 h4(\"Interpretation\"),\n                                 textOutput(\"interpretation_pred\")\n                          )\n                        )\n                        \n                      )\n                    )\n                  )\n                 ),\n                 footer = tags$footer(\n                   style = \"\n                    position: fixed;\n                    bottom: 0;\n                    left: 0;\n                    width: 100%;\n                    background-color: #f8f9fa;\n                    border-top: 1px solid #ddd;\n                    text-align: center;\n                    padding: 8px;\n                    font-size: 12px;\n                    color: #6c757d;\n                    z-index: 1000;\n                  \",\n                   \"2025 Created by Shahriar Shams and Issey Sone\"\n                 )\n)\n\nserver <- function(input, output, session) {\n  \n  \n  \n  parseVector <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 2 || any(is.na(vals))) return(NULL)\n    vals\n  }\n  \n  parseMatrix <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 4 || any(is.na(vals))) return (NULL)\n    matrix(vals, nrow = 2, byrow = TRUE)\n  }\n  \n  \n  simulation_results <- reactiveVal(NULL)\n\n  simulation_results_mvt <- reactiveVal(NULL)\n  \n  \n  \n  # single variable generation\n  observeEvent(input$run_simulation, {\n    \n    n_sim <- 1000\n    n <- input$n_draws\n    x_mean <- 10\n    x_sd <- 2\n    var_x <- x_sd^2\n    \n    error_var <- input$sigmasq\n    \n    beta0hat <- numeric(n_sim)\n    beta1hat <- numeric(n_sim)\n    \n    set.seed(123)\n    X <- rnorm(n, mean = x_mean, sd = x_sd)\n    \n    \n    \n    \n    Sxx <- sum((X - mean(X))^2)\n    \n    var_beta1 <- error_var / Sxx\n    var_beta0 <- error_var * (1/n + mean(X)^2 / Sxx)\n    cov_beta01 <- -error_var * mean(X) / (Sxx)\n    \n    beta_vals <- parseVector(input$betas)\n    beta0_true <- beta_vals[1]\n    beta1_true <- beta_vals[2]\n    \n    \n    for (i in 1:n_sim) {\n      epsilon <- rnorm(n, mean = 0, sd = sqrt(error_var))\n      Y <- beta0_true + X * beta1_true + epsilon \n      model <- lm(Y ~ X)\n      \n      beta0hat[i] <- coef(model)[1]\n      beta1hat[i] <- coef(model)[2]\n    }\n    \n    \n    results <- data.frame(\n      simulation = 1:n_sim,\n      beta0hat = beta0hat,\n      beta1hat = beta1hat\n    )\n    \n    simulation_results(results)\n    \n    mu_x <- x_mean\n    Sigma <- matrix(c(var_beta1, cov_beta01,\n                      cov_beta01, var_beta0), nrow = 2)\n    \n    ellipse_pts <- as.data.frame(ellipse(\n      x = Sigma,\n      centre = c(beta1_true, beta0_true),\n      level = 0.95,\n      npoints = 200\n    ))\n    \n    colnames(ellipse_pts) <- c(\"beta1hat\", \"beta0hat\")\n    \n    simulation_results(list(data = results, ellipse = ellipse_pts,\n                            beta0_true = beta0_true, beta1_true = beta1_true,\n                            var_beta0 = var_beta0, var_beta1 = var_beta1,\n                            cov_beta01 = cov_beta01))\n  })\n\n  # Multivariable generation\n  observeEvent(input$run_simulation_mv, {\n    set.seed(123)\n    n <- input$n_draws_mvt\n    \n   \n    x1 <- rnorm(n, mean = 10, sd = 2)\n    \n    \n    X <- cbind(1, x1)\n    n_sim <- 1000\n    beta01hat <- numeric(n_sim)\n    beta11hat <- numeric(n_sim)\n    beta02hat <- numeric(n_sim)\n    beta12hat <- numeric(n_sim)\n\n    epsilon_sigma <- parseMatrix(input$sigmasq_mv)\n\n    epsilon_center <- c(0, 0)\n    \n\n    beta_vals <- parseMatrix(input$betas_mv)\n    beta01_true <- beta_vals[1, 1]\n    beta11_true <- beta_vals[1, 2]\n    beta02_true <- beta_vals[2, 1]\n    beta12_true <- beta_vals[2, 2]\n    B <- matrix(c(beta01_true, beta02_true, beta11_true, beta12_true), nrow = 2, byrow = TRUE)\n\n    for (i in 1:n_sim) {\n      epsilon <- mvrnorm(n = n, mu = epsilon_center, Sigma = epsilon_sigma)\n      \n      Y <- X %*% B + epsilon\n      \n      Y1 <- Y[,1]\n      Y2 <- Y[,2]\n      \n      model <- lm(cbind(Y1, Y2) ~ x1)\n      \n      coefs <- coef(model)\n      \n\n      beta01hat[i] <- coefs[1, 1]\n      beta11hat[i] <- coefs[2, 1]\n      beta02hat[i] <- coefs[1, 2]\n      beta12hat[i] <- coefs[2, 2]\n    }\n\n    results <- data.frame(\n      simulation = 1:n_sim,\n      beta01hat = beta01hat,\n      beta11hat = beta11hat,\n      beta02hat = beta02hat,\n      beta12hat = beta12hat\n    )\n\n    Sxx1 <- sum((x1 - mean(x1))^2)\n\n    cov_beta01 <- epsilon_sigma[1,1] * (1/n + mean(x1)^2/Sxx1)\n    var_beta11 <- epsilon_sigma[1,1] / Sxx1\n    cov_beta01_beta11 <- -epsilon_sigma[1,1] * mean(x1) / Sxx1\n    \n    cov_beta02 <- epsilon_sigma[2,2] * (1/n + mean(x1)^2/Sxx1)\n    var_beta12 <- epsilon_sigma[2,2] / Sxx1\n    cov_beta02_beta12 <- -epsilon_sigma[2,2] * mean(x1) / Sxx1\n    \n    cov_beta01_beta02 <- epsilon_sigma[1,2] * (1/n + mean(x1)^2/Sxx1)\n    cov_beta01_beta12 <- -epsilon_sigma[1,2] * mean(x1) / Sxx1\n    cov_beta11_beta02 <- -epsilon_sigma[1,2] * mean(x1) / Sxx1 \n    cov_beta11_beta12 <- epsilon_sigma[1,2] / Sxx1\n    \n    theoretical_cov <- matrix(c(\n      cov_beta01, cov_beta01_beta11, cov_beta01_beta02, cov_beta01_beta12,\n      cov_beta01_beta11, var_beta11, cov_beta11_beta02, cov_beta11_beta12,\n      cov_beta01_beta02, cov_beta11_beta02, cov_beta02, cov_beta02_beta12,\n      cov_beta01_beta12, cov_beta11_beta12, cov_beta02_beta12, var_beta12\n    ), nrow = 4, ncol = 4)\n    \n    rownames(theoretical_cov) <- colnames(theoretical_cov) <- c(\"B01\", \"B11\", \"B02\", \"B12\")\n\n    simulation_results_mvt(list(\n      data = results,\n      theoretical_cov = theoretical_cov,\n      true_betas = c(beta01_true, beta11_true, beta02_true, beta12_true),\n      epsilon_sigma = epsilon_sigma,\n      x1_mean = mean(x1), \n      Sxx1 = Sxx1\n    ))\n  })\n  \n  # single variable plots\n  output$bivariate_plot <- renderPlotly({\n    req(simulation_results())\n    \n    sim <- simulation_results()\n    \n    results <- sim$data\n    ellipse_pts <- sim$ellipse\n    \n    beta0_true <- sim$beta0_true\n    beta1_true <- sim$beta1_true\n    \n    p <- ggplot(results, aes(x = beta1hat, y = beta0hat)) +\n      geom_point(alpha = 0.6, size = 1, color = \"steelblue\") +\n      geom_vline(xintercept = beta1_true, color = \"black\", linetype = \"solid\", size = 0.5) +\n      geom_hline(yintercept = beta0_true, color = \"black\", linetype = \"solid\", size = 0.5) +\n      xlim(-1, 2) + \n      ylim(-10, 12) + \n      labs(\n        title = \"Joint Distribution of β₀ and β₁ Estimators\",\n        x = \"β₁ (Slope Estimate)\",\n        y = \"β₀ (Intercept Estimate)\"\n      ) +\n      theme_minimal() +\n      theme(\n        plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\"\n      )\n    \n    ggplotly(p, tooltip = c(\"x\", \"y\"))\n    \n  })\n  \n  output$theoretical_info <- renderText({\n    req(simulation_results())\n    sim <- simulation_results()\n    paste0(\n      \"E[β₀] = \", sim$beta0_true, \"\\n\",\n      \"E[β₁] = \", sim$beta1_true, \"\\n\",\n      \"Var(β₀) = \", round(sim$var_beta0, 4), \"\\n\",\n      \"Var(β₁) = \", round(sim$var_beta1, 4), \"\\n\",\n      \"Cov(β₀,β₁) = \", round(sim$cov_beta01, 4), \"\\n\",\n      \"Corr(β₀,β₁) = \", round(sim$cov_beta01/sqrt(sim$var_beta0 * sim$var_beta1), 4)\n    )\n    \n  })\n  \n  output$marginal_plots <- renderPlot({\n    req(simulation_results())\n    \n    sim <- simulation_results()\n    \n    data <- sim$data\n    \n    beta0_true <- sim$beta0_true\n    beta1_true <- sim$beta1_true\n    var_beta0 <- sim$var_beta0\n    var_beta1 <- sim$var_beta1\n    \n    \n    \n    suppressWarnings({p1 <- ggplot(data, aes(x = beta0hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightblue\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = beta0_true, color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(data$beta0hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm, args = list(mean = beta0_true, sd = sqrt(var_beta0)), color = \"black\", linetype = \"dashed\", size = 1) +\n      labs(title = \"β₀ Distribution\", x = \"β₀\", y = \"Density\") +\n      xlim(-15, 15)+\n      theme_minimal()\n    })\n    \n    suppressWarnings({p2 <- ggplot(data, aes(x = beta1hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightgreen\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = beta1_true, color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(data$beta1hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm,\n                    args = list(mean = beta1_true, sd = sqrt(var_beta1)), color = \"black\", linetype = \"dashed\", size = 1) + \n      labs(title = \"β₁ Distribution\", x = \"β₁\", y = \"Density\") +\n      xlim(-1, 2)\n      theme_minimal()\n    })\n    \n    gridExtra::grid.arrange(p1, p2, ncol = 1)\n  })\n\n  # multivariate plots\n\n  output$multivariate_joint_plot1 <- renderPlotly({\n    req(simulation_results_mvt())\n\n    results <- simulation_results_mvt()$data\n    true_betas <- simulation_results_mvt()$true_betas\n\n    p1 <- ggplot(results, aes(x = beta01hat, y = beta11hat)) +\n      geom_point(alpha = 0.6, size = 1, color = \"steelblue\") +\n      geom_vline(xintercept = true_betas[1], color = \"black\", linetype = \"dashed\") + \n      geom_hline(yintercept = true_betas[2], color = \"black\", linetype = \"dashed\") + \n      labs(title = \"β01 vs β11\", x = \"β01\", y = \"β11\") + \n      theme_minimal()\n\n    ggplotly(p1, tooltip = c(\"x\", \"y\"))\n\n  })\n  \n  output$multivariate_joint_plot2 <- renderPlotly({\n    req(simulation_results_mvt())\n    results <- simulation_results_mvt()$data\n    true_betas <- simulation_results_mvt()$true_betas\n\n    p1 <- ggplot(results, aes(x = beta02hat, y = beta12hat)) +\n      geom_point(alpha = 0.6, size = 1, color = \"royalblue\") + \n      geom_vline(xintercept = true_betas[3], color = \"black\", linetype = \"dashed\") + \n      geom_hline(yintercept = true_betas[4], color = \"black\", linetype = \"dashed\") +\n      labs(title = \"β02 vs β12\", x= \"B02\", y = \"B12\") + \n      theme_minimal()\n    \n    ggplotly(p1, tooltip = c(\"x\", \"y\"))\n  })\n  \n  \n  output$summary_table <- DT::renderDT({\n    req(simulation_results_mvt())\n    \n    results <- simulation_results_mvt()$data\n    true_betas <- simulation_results_mvt()$true_betas\n    \n    summary_data <- data.frame(\n      Parameter = c(\"β₀₁\", \"β₁₁\", \"β₀₂\", \"β₁₂\"),\n      True_Value = true_betas,\n      Mean_Estimate = c(mean(results$beta01hat), mean(results$beta11hat), \n                        mean(results$beta02hat), mean(results$beta12hat)),\n      SD_Estimate = c(sd(results$beta01hat), sd(results$beta11hat),\n                      sd(results$beta02hat), sd(results$beta12hat)),\n      Bias = c(mean(results$beta01hat) - true_betas[1], \n               mean(results$beta11hat) - true_betas[2],\n               mean(results$beta02hat) - true_betas[3],\n               mean(results$beta12hat) - true_betas[4])\n    )\n    \n    datatable(summary_data, options = list(dom = 't')) %>%\n      formatRound(columns = c('True_Value', 'Mean_Estimate', 'SD_Estimate', 'Bias'), digits = 4)\n  })\n  \n  output$comparison_output <- renderText({\n    req(simulation_results_mvt())\n    \n    results <- simulation_results_mvt()$data\n    theoretical_cov <- simulation_results_mvt()$theoretical_cov\n    \n    empirical_cov <- cov(results[, -1])  \n    \n    paste0(\n      \"Expected Covariance Matrix:\\n\",\n      paste(capture.output(print(round(theoretical_cov, 4))), collapse = \"\\n\"),\n      \"\\n\\nEmpirical Covariance Matrix:\\n\", \n      paste(capture.output(print(round(empirical_cov, 4))), collapse = \"\\n\")\n    )\n  })\n  \n  output$cov_matrix_display <- renderText({\n    req(simulation_results_mvt())\n    \n    theoretical_cov <- simulation_results_mvt()$theoretical_cov\n    \n    paste0(\n      \"Expected Covariance Matrix of β̂:\\n\",\n      paste(capture.output(print(round(theoretical_cov, 4))), collapse = \"\\n\")\n    )\n  })\n  \n  \n  output$multivariate_marginal_plots <- renderPlot({\n    req(simulation_results_mvt())\n    results <- simulation_results_mvt()$data\n    true_betas <- simulation_results_mvt()$true_betas\n    theoretical_cov <- simulation_results_mvt()$theoretical_cov\n    \n    p1 <- ggplot(results, aes(x = beta01hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightblue\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = true_betas[1], color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(results$beta01hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm, args = list(mean = true_betas[1], sd = sqrt(theoretical_cov[1,1])), \n                    color = \"black\", linetype = \"dashed\", size = 1) +\n      labs(title = \"β₀₁ Distribution\", x = \"β₀₁\", y = \"Density\") +\n      theme_minimal()\n    \n    p2 <- ggplot(results, aes(x = beta11hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightgreen\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = true_betas[2], color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(results$beta11hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm, args = list(mean = true_betas[2], sd = sqrt(theoretical_cov[2,2])), \n                    color = \"black\", linetype = \"dashed\", size = 1) +\n      labs(title = \"β₁₁ Distribution\", x = \"β₁₁\", y = \"Density\") +\n      theme_minimal()\n    \n    p3 <- ggplot(results, aes(x = beta02hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightcoral\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = true_betas[3], color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(results$beta02hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm, args = list(mean = true_betas[3], sd = sqrt(theoretical_cov[3,3])), \n                    color = \"black\", linetype = \"dashed\", size = 1) +\n      labs(title = \"β₀₂ Distribution\", x = \"β₀₂\", y = \"Density\") +\n      theme_minimal()\n    \n    p4 <- ggplot(results, aes(x = beta12hat)) +\n      geom_histogram(bins = 50, alpha = 0.7, fill = \"lightyellow\", color = \"black\", aes(y = ..density..)) +\n      geom_vline(xintercept = true_betas[4], color = \"red\", linetype = \"solid\", size = 1) +\n      geom_vline(xintercept = mean(results$beta12hat), color = \"blue\", linetype = \"dashed\") +\n      stat_function(fun = dnorm, args = list(mean = true_betas[4], sd = sqrt(theoretical_cov[4,4])), \n                    color = \"black\", linetype = \"dashed\", size = 1) +\n      labs(title = \"β₁₂ Distribution\", x = \"β₁₂\", y = \"Density\") +\n      theme_minimal()\n    \n    gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 2)\n    \n  })\n  \n  \n  # prediction ellipse\n  \n  observeEvent(input$generate_pred_data, {\n    set.seed(123)\n    \n    n <- input$n_pred\n    beta_vals <- parseMatrix(input$betas_mv_pred)\n    beta01 <- beta_vals[1, 1]\n    beta11 <- beta_vals[1, 2]\n    beta02 <- beta_vals[2, 1]\n    beta12 <- beta_vals[2, 2]\n    \n    B <- matrix(c(beta01, beta02, beta11, beta12), nrow = 2)\n    \n    \n    \n    epsilon_sigma <- parseMatrix(input$sigmasq_mv_pred)\n    \n    epsilon_center <- c(0, 0)\n    \n    epsilon <- mvrnorm(n = n, mu = epsilon_center, Sigma = epsilon_sigma)\n    \n    x1 <- rnorm(n, mean = 10, sd = 2)\n    \n    X <- cbind(1, x1)\n    \n    Y <- X %*% B + epsilon\n    \n    Y1 <- Y[,1]\n    Y2 <- Y[,2]\n    \n    model <- lm(cbind(Y1, Y2) ~ x1)\n    \n    coefs <- coef(model)\n    \n    new_X <- c(1, input$x_new)\n    \n    Y_hat <- new_X %*% coefs\n    \n    XtX_inv <- solve(t(X) %*% X)\n    \n    quad_form <- t(new_X) %*% XtX_inv %*% new_X\n    \n    pred_cov <- (1 + as.numeric(quad_form)) * epsilon_sigma\n    \n    ellipse_df <- as.data.frame(ellipse(pred_cov, centre = Y_hat, level = input$conf_level))\n    colnames(ellipse_df) <- c(\"Y1\", \"Y2\")\n    \n    \n    \n    alpha <- 1 - input$conf_level\n    \n    F_val <- qf(1 - alpha, df1 = 2, df2 = n - 2)\n    c_val <- 2 * (n - 1) * F_val / (n - 2)\n    \n    Y1_lower <- Y_hat[1] - sqrt(c_val * pred_cov[1, 1])\n    Y1_upper <- Y_hat[1] + sqrt(c_val * pred_cov[1, 1])\n    Y2_lower <- Y_hat[2] - sqrt(c_val * pred_cov[2, 2])\n    Y2_upper <- Y_hat[2] + sqrt(c_val * pred_cov[2, 2])\n    \n    p <-ggplot(ellipse_df, aes(x = Y1, y = Y2)) +\n      geom_path(color = \"blue\") +\n      geom_point(aes(x = Y_hat[1], y = Y_hat[2]), color = \"red\", size = 1) +\n      geom_rect(aes(xmin = Y1_lower, xmax = Y1_upper,\n                    ymin = Y2_lower, ymax = Y2_upper),\n                fill = NA, color = \"skyblue\", linetype = \"dashed\") +\n      coord_fixed() +\n      labs(title = \"95% Prediction Ellipse with Simultaneous T² Intervals\",\n           x = \"Predicted Y1\", y = \"Predicted Y2\") +\n      theme_minimal()\n    \n    \n    output$prediction_plot <- renderPlotly(\n      ggplotly(p)\n    )\n    \n    \n  })\n  \n  \n  # interpretations\n  output$interpretation_uni <- renderText({\n    \"Increasing the variance of the error term causes the spread to be higher in both Beta0 and Beta1. Increasing the number of observations will make the spread tighter. Try making sense\n    of this by looking at the formula on the top of the screen. \"\n  })\n  \n  output$interpretation_mv <- renderText({\n    \"The same observations from the univarate case extend to the multivaraite case. However, adding a covariance term in the covariance matrix for epsilon\n    will cause the joint distribution of the betas will be affected. (See equation below and Result 7.9 in textbook)\"\n  })\n  \n  \n  output$interpretation_pred <- renderText({\n    \"Adding a covariance term to sigma will make the ellipse diagonal, making the confidence region larger will make the ellipse larger.\n    Increasing n will make the ellipse shrink, this might be hard to visually but pay attention to the values in axis of the graph.\"\n  })\n\n\n\n\n}\n\nshinyApp(ui = ui, server = server)","type":"text"}]
