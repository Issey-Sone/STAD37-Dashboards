[{"name":"app.R","content":"library(shiny)\nlibrary(tidyverse)\nlibrary(MASS)\nlibrary(shinythemes)\n\n\nif (FALSE) library(munsell)\n\nui <- navbarPage(\"Classification Dashboard\",\n                 theme = shinytheme(\"flatly\"),\n                 tabPanel(\"Classification of Normal Population\",\n                    withMathJax(\n                      helpText(\"$$\n                        a = \\\\Sigma^{-1}(\\\\mu_1 - \\\\mu2) \\\\hspace{2em} \\\\text{$\\\\Sigma = $ pooled covariance matrix} \\\\\\\\\n                        y = a^{T}x\n                        $$\")\n                    ),\n                    fluidPage(\n                      sidebarLayout(\n                        sidebarPanel(\n                          h3(\"Data Generation Parameters\"),\n                          numericInput(\"n1\", \"Sample Size for Group 1\", value = 100, min = 10, max = 1000),\n                          numericInput(\"n2\", \"Sample Size for Group 2\", value = 100, min = 10, max = 1000),\n                          \n                          h4(\"Group 1\"),\n                          textInput(\"mu_g1\", \"Mean of Group 1: eg(4, 3)\", value = \"4, 3\"),\n                          numericInput(\"cov_g1\",\"Covariance for Group 1 (has to be less than 3)\", value = 0, step = 0.1, max = 3),\n                          \n                          h4(\"Group 2\"),\n                          textInput(\"mu_g2\", \"Mean of Group 2: eg(9, 5)\", value = \"9, 5\"),\n                          numericInput(\"cov_g2\", \"Covariance for Group 2 (has to be less than 3)\", value = 0, step = 0.1, max = 3),\n                          \n                          br(),\n                          actionButton(\"generate\", \"Generate New Data\", class = \"btn-primary\"),\n                          actionButton(\"classify\", \"Apply Linear Discriminant\", class = \"btn-success\"),\n                          h4(\"Classify New Point\"),\n                          textInput(\"new_point\", \"New Point (x, y)\", value = \"5, 5\"),\n                          actionButton(\"classify_new\", \"Classify New Point\", class = \"btn-warning\"),\n                          verbatimTextOutput(\"new_point_result\"),\n                          br(),\n                          br(),\n                          br()\n                          \n                        ),\n                        mainPanel(\n                          tabsetPanel(\n                            tabPanel(\"Scatter Plot\",\n                                     plotOutput(\"scatterplot\", height = '600px'),\n                                     h4(\"Classification Results\"),\n                                     verbatimTextOutput(\"accuracy\"),\n                                     fluidRow(\n                                       column(12,\n                                              h4(\"Interpretation\"),\n                                              textOutput(\"interpretation1\")\n                                       )\n                                     ),\n                                     br(),\n                                     br(),\n                                     br()\n                            ),\n                            tabPanel(\"Fisher's Approach Details\",\n                                     h4(\"Linear Discriminant Function\"),\n                                     verbatimTextOutput(\"lda_function\"),\n                                     h4(\"Discriminant Coefficients\"),\n                                     verbatimTextOutput(\"lda_coefficients\"),\n                                     h4(\"Group Means\"),\n                                     verbatimTextOutput(\"group_means\"),\n                                     fluidRow(\n                                       column(12,\n                                              h4(\"Interpretation\"),\n                                              textOutput(\"interpretation2\")\n                                       )\n                                     ),\n                                     br(),\n                                     br(),\n                                     br()\n                            ),\n                            tabPanel(\"Projected Points\", \n                                     plotOutput(\"projection_plot\", height = \"600px\"),\n                                     plotOutput(\"histogram_plot\", height = \"600px\"),\n                                     fluidRow(\n                                       column(12,\n                                              h4(\"Interpretation\"),\n                                              textOutput(\"interpretation3\")\n                                       )\n                                     ),\n                                     br(),\n                                     br(),\n                                     br()\n                                     \n                            )\n                          )\n                        )\n                      )\n                    )\n            ),\n            footer = tags$footer(\n              style = \"\n                position: fixed;\n                bottom: 0;\n                left: 0;\n                width: 100%;\n                background-color: #f8f9fa;\n                border-top: 1px solid #ddd;\n                text-align: center;\n                padding: 8px;\n                font-size: 12px;\n                color: #6c757d;\n                z-index: 1000;\n              \",\n              \"2025 Created by Shahriar Shams and Issey Sone\"\n            )\n        \n)\n\n\nserver <- function(input, output, session) {\n  values <- reactiveValues(\n    data = NULL,\n    lda_model = NULL,\n    lda_applied = FALSE\n  )\n  \n  observeEvent(input$generate, {\n    generate_data()\n  })\n  \n  \n  observe({\n    req(input$n1, input$n2)             \n    req(input$mu_g1, input$mu_g2)        \n    req(input$cov_g1, input$cov_g2)     \n    \n    mu1_vals <- as.numeric(unlist(strsplit(input$mu_g1, \",\")))\n    mu2_vals <- as.numeric(unlist(strsplit(input$mu_g2, \",\")))\n    \n    validate(\n      need(length(mu1_vals) == 2 && all(!is.na(mu1_vals)), \"Enter 2 numbers for Group 1 mean.\"),\n      need(length(mu2_vals) == 2 && all(!is.na(mu2_vals)), \"Enter 2 numbers for Group 2 mean.\")\n    )\n    \n    generate_data()\n    \n    generate_data()\n  })\n  \n  observe({\n    if (is.null(values$data)) {\n      generate_data()\n    }\n  })\n  \n  parseVector <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 2 || any(is.na(vals))) return(NULL)\n    vals\n  }\n  \n  generate_data <- function() {\n    cov1 <- matrix(c(3, input$cov_g1, input$cov_g1, 3), nrow = 2)\n    cov2 <- matrix(c(3, input$cov_g2, input$cov_g2, 3), nrow = 2)\n    \n    mu1 <- parseVector(input$mu_g1)\n    mu2 <- parseVector(input$mu_g2)\n    \n    group1 <- mvrnorm(input$n1, mu = mu1, Sigma = cov1)\n    group2 <- mvrnorm(input$n2, mu = mu2, Sigma = cov2)\n    \n    data <- data.frame(\n      x = c(group1[, 1], group2[, 1]),\n      y = c(group1[, 2], group2[, 2]),\n      group = factor(c(rep(\"Group 1\", input$n1), rep(\"Group 2\", input$n2)))\n    )\n    \n    values$data <- data\n    values$lda_applied <- FALSE\n    values$lda_model <- NULL\n  }\n  \n  observeEvent(input$classify_new, {\n    req(values$lda_applied, values$lda_model)\n    \n    value <- parseVector(input$new_point)\n    \n    new_point <- data.frame(\n      x = value[1],\n      y = value[2]\n    )\n    \n    pred <- predict(values$lda_model, new_point)\n    \n    output$new_point_result <- renderText({\n      paste0(\"New point classified as: \", pred$class)\n    })\n    values$new_point <- new_point\n    values$new_point$predicted_class <- pred$class\n    \n  })\n    \n  \n  observeEvent(input$classify, {\n    if(!is.null(values$data)) {\n      lda_model <- lda(group ~ x + y, data = values$data)\n      \n      predictions <- predict(lda_model, values$data)\n      \n      values$data$predicted <- predictions$class\n      values$data$ld1 <- predictions$x[, 1]\n      \n      values$lda_model <- lda_model\n      values$lda_applied <- TRUE\n    }\n  })\n  output$scatterplot <- renderPlot({\n    if (is.null(values$data)) return()\n    \n    p <- ggplot(values$data, aes(x=x, y=y)) +\n    \tgeom_point(aes(color = group, shape = group), size = 3, alpha = 0.9) +\n    \tscale_color_manual(values = c(\"Group 1\" = \"darkorchid1\", \"Group 2\" = \"aquamarine2\")) +\n    \tscale_shape_manual(values = c(\"Group 1\" = 19, \"Group 2\" = 17)) +\n     \tlabs(\n        x = \"x\",\n    \t  y = \"y\",\n    \t  title = \"Bivariate Normal Classification\",\n    \t  color = \"Group\",\n    \t  shape = \"Group\"\n    \t) +\n    \ttheme_minimal() + \n    \ttheme(\n    \t  legend.position = \"bottom\",\n    \t  plot.title = element_text(hjust = 0.5, size = 16),\n    \t  axis.title = element_text(size = 12),\n    \t  legend.title = element_text(size = 12)\n    \t)\n    if (nrow(values$data) > 0) {\n      p <- p + stat_ellipse(aes(color = group), level = 0.9, type = \"norm\", linetype = \"dashed\")\n    }\n    \n    \n    if(values$lda_applied && !is.null(values$lda_model)) {\n      \n      mu1 <- values$lda_model$means[1, ]\n      mu2 <- values$lda_model$means[2, ]\n      \n      pooled_cov <- cov(values$data[values$data$group == \"Group 1\", 1:2]) * (input$n1 - 1) +\n        cov(values$data[values$data$group == \"Group 2\", 1:2]) * (input$n2 - 1)\n      pooled_cov <- pooled_cov / (input$n1 + input$n2 - 2)\n      \n      inv_S <- solve(pooled_cov)\n      a_vec <- inv_S %*% (mu1 - mu2)\n      \n      prior1 <- input$n1 / (input$n1 + input$n2)\n      prior2 <- input$n2 / (input$n1 + input$n2)\n      \n      intercept_val <- 0.5 * (t(mu1) %*% inv_S %*% mu1 - \n                                t(mu2) %*% inv_S %*% mu2) - log(prior1 / prior2)\n      \n      slope <- -a_vec[1] / a_vec[2]\n      intercept <- intercept_val / a_vec[2]\n      \n      p <- p + geom_abline(slope = slope, intercept = intercept,\n                           color = \"red\", size = 1.2, linetype = \"solid\") + \n        annotate(\"text\", x = Inf, y = Inf, label = \"Fisher's Discriminant Line\",\n                 hjust = 1.1, vjust = 2, color = \"red\", size = 4)\n      \n      if (\"predicted\" %in% names(values$data)) {\n        misclassified <- values$data[values$data$group != values$data$predicted, ]\n        if (nrow(misclassified) > 0) {\n          p <- p + geom_point(data = misclassified, aes(x=x, y=y),\n                              color = \"red\", size = 3, shape = 4, stroke = 1)\n        }\n      }\n    }\n    \n    \n    if (!is.null(values$new_point)) {\n      p <- p + geom_point(data = values$new_point, aes(x = x, y = y),\n                          fill = ifelse(values$new_point$predicted_class == \"Group 1\", \"darkorchid1\", \"aquamarine2\"),\n                          color = \"black\",\n                          size = 3, shape = ifelse(values$new_point$predicted_class == \"Group 1\", 21, 24), stroke = 1.5) \n    }\n    p\n    \n\t})\t\n  output$lda_function <- renderText({\n    if (!values$lda_applied || is.null(values$lda_model)) {\n      return(\"Apply Fisher's LDA to see the discriminant function\")\n    }\n    coef <- values$lda_model$scaling\n    paste0(\"Linear Discriminant Function: \\n\",\n           \"LD = \", round(coef[1], 4), \"x + \", round(coef[2], 4), \"y\")\n  })\n  \n  output$accuracy <- renderText({\n    if(!values$lda_applied || !(\"predicted\" %in% names(values$data))) {\n      return(\"Apply Fisher's LDA to see classification accuracy.\")\n    }\n    \n    accuracy <- mean(values$data$group == values$data$predicted)\n    confusion <- table(Predicted = values$data$predicted, Actual = values$data$group)\n    \n    confusion_str <- apply(confusion, 1, function(row) paste(row, collapse = \"\\t\"))\n    confusion_output <- paste(\n      \"           \\tGroup 1 Group 2\",\n      paste(\"Predicted Group 1:\", confusion_str[1]),\n      paste(\"Predicted Group 2:\", confusion_str[2]),\n      sep = \"\\n\"\n    )\n    \n    paste0(\n      \"Classification Accuracy: \", round(accuracy * 100, 2), \"%\\n\\n\",\n      \"Confusion Matrix:\\n\", confusion_output\n    )\n  })\n  \n  output$lda_coefficients <- renderText({\n    if(!values$lda_applied || is.null(values$lda_model)) {\n      return(\"Apply Fisher's LDA to see coefficients.\")\n    }\n    \n    coef <- values$lda_model$scaling\n    paste0(\"Coefficient for X: \", round(coef[1], 4), \"\\n\",\n           \"Coefficient for Y: \", round(coef[2], 4))\n  })\n  \n  output$group_means <- renderText({\n    if(!values$lda_applied || is.null(values$lda_model)) {\n      return(\"Apply Fisher's LDA to see group means.\")\n    }\n    \n    means <- values$lda_model$means\n    paste0(\"Group Means in discriminant Space: \\n\",\n           \"X: \", round(means[1, 1], 4), \", \", round(means[1, 2], 4), \"\\n\",\n           \"Y: \", round(means[2, 1], 4), \", \", round(means[2, 2], 4))\n  }) \n  \n  observeEvent(input$classify, {\n    if (!is.null(values$data)) {\n      lda_model <- lda(group ~ x + y, data = values$data)\n      \n      predictions <- predict(lda_model, values$data)\n      \n      S_pooled <- lda_model$scaling %*% t(lda_model$scaling) \n      mean_diff <- colMeans(values$data[values$data$group == \"Group 1\", 1:2]) - \n        colMeans(values$data[values$data$group == \"Group 2\", 1:2])\n      a_vec <- lda_model$scaling  \n      \n      fisher_projection <- as.matrix(values$data[, 1:2]) %*% a_vec  \n      values$data$projected <- fisher_projection  \n      \n      values$data$predicted <- predictions$class\n      values$data$ld1 <- predictions$x[, 1]  \n      \n      values$lda_model <- lda_model\n      values$lda_applied <- TRUE\n    }\n  })\n  \n  \n  output$projection_plot <- renderPlot({\n    validate(\n      need(values$lda_applied, \"Apply Linear Discriminant to see the projection plot.\"),\n      need(!is.null(values$data$projected), \"Projected data isn't available\")\n    )\n    \n    projected_data <- data.frame(\n      LD1 = values$data$projected,\n      group = values$data$group\n    )\n    \n    means <- projected_data %>%\n      group_by(group) %>%\n      summarise(mean_LD1 = mean(LD1), .groups = \"drop\")\n    \n    y1bar <- means$mean_LD1[means$group == \"Group 1\"]\n    y2bar <- means$mean_LD1[means$group == \"Group 2\"]\n    cutoff <- 0.5 * (y1bar + y2bar)\n    \n    ggplot(projected_data, aes(x = LD1, y = 0, color = group)) +\n      geom_jitter(aes(y=0), height = 0.05, width = 0, size = 2, alpha = 0.7) +\n      geom_vline(xintercept = cutoff, color = \"red\", linetype = \"dashed\", size = 1) +\n      annotate(\"text\", x = cutoff, y = 0.2,\n               label = paste0(\"Cutoff = \", round(cutoff, 2)),\n               color = \"red\", angle = 90, vjust = -0.5) +\n      labs(\n        title = \"Fisher’s Transformation – Points Projected on Discriminant Line\",\n        x = \"Projection y = aᵀx\",\n        y = NULL\n      ) +\n      scale_color_manual(values = c(\"Group 1\" = \"darkorchid3\", \"Group 2\" = \"aquamarine2\")) +\n      theme_minimal() +\n      theme(\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank()\n      )\n  })\n  \n  \n  output$histogram_plot <- renderPlot({\n    validate(\n      need(values$lda_applied, \"Apply Linear Discriminant to see the projection plot.\"),\n      need(!is.null(values$data$projected), \"Projected data isn't available\")\n    )\n    \n    projected_data <- data.frame(\n      LD1 = values$data$projected,\n      group = values$data$group\n    )\n    \n    means <- projected_data %>%\n      group_by(group) %>%\n      summarise(mean_LD1 = mean(LD1), .groups = \"drop\")\n    \n    y1bar <- means$mean_LD1[means$group == \"Group 1\"]\n    y2bar <- means$mean_LD1[means$group == \"Group 2\"]\n    cutoff <- 0.5 * (y1bar + y2bar)\n    \n    ggplot(projected_data, aes(x = LD1, fill = group)) +\n      geom_histogram(\n        aes(y = ..density..), \n        position = \"identity\", \n        bins = 30, \n        alpha = 0.6, \n        color = \"black\"\n      ) +\n      geom_vline(xintercept = cutoff, color = \"red\", linetype = \"dashed\", size = 1) +\n      annotate(\"text\", x = cutoff, y = 0.25,\n               label = paste0(\"Cutoff = \", round(cutoff, 2)),\n               color = \"red\", angle = 90, vjust = -0.5) +\n      labs(\n        title = \"Fisher’s Transformation – Histogram of Projected Points\",\n        x = \"Projection y = aᵀx\",\n        y = \"Density\"\n      ) +\n      scale_fill_manual(values = c(\"Group 1\" = \"darkorchid3\", \"Group 2\" = \"aquamarine2\")) +\n      theme_minimal()\n  })\n  \n  # Interepretations\n  \n  output$interpretation1 <- renderText({\n    \"The plot shows two bivariate normal populations with different means each with a value of 3 as the diagonal element in the covariance matrix.\n    If the seperability isn't good the two centers are likely too close to each other. Remember\n    Fisher's approach doesn't assume normality of data, but assumes population level covariance matrices are the same. If the covariance term is different then the\n    optimal boundary should be quadratic. See Fisher's approach details for an interpretation of the boundary.\"\n  })\n  \n  output$interpretation2 <- renderText({\n    \"The red line is Fisher's linear discriminant boundary, which is a straight-line perpendicular to the direction 'a' that seperates the two class means. If\n    both groups had the same covariance and equal sample size, this line would be the perpendicular bisector of the line segment connecting two class means. \n    If sample sizes differ, the line shifts toward the larger group which would be reflective of having\n    a higher prior probability for that group. \"\n  })\n  \n  output$interpretation3 <- renderText({\n    \"This plot shows the points in the projected space which is only 1D. The center is the average between the two transformed centers.\"\n  })\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"}]
