[{"name":"app.R","content":"library(shiny)\nlibrary(shinythemes)\nlibrary(tidyverse)\nlibrary(mvtnorm)\nlibrary(plotly)\nlibrary(metR)\n\nui <- navbarPage(\n  title = \"STAD37 Bivariate Normal Visualizer\",\n  theme = shinytheme(\"flatly\"),\n  \n  tabPanel(\"Interactive Viewer\",\n           sidebarLayout(\n             sidebarPanel(\n               h4(\"Mean Vector (μ):\"),\n               textInput(\"mu\", \"μ (e.g., 0, 0):\", value = \"0, 0\"),\n               \n               \n               h4(\"Covariance Matrix (Σ):\"),\n               textInput(\"sigma\", \"Σ (row-wise, e.g., 1, 0, 0, 1):\", value = \"1, 0, 0, 1\"),\n               \n               helpText(\"Insert values with a , as the delimeter\"),\n               \n               \n             ),\n             \n             mainPanel(\n               tabsetPanel(\n                 tabPanel(\"3D Plot\",\n                          h4(\"3D Density Plot\"),\n                          plotlyOutput(\"densityPlot\", height = \"700px\"),\n                          fluidRow(\n                            column(12,\n                                   h4(\"Interpretation\"),\n                                   textOutput(\"interpretation1\")\n                            )\n                          ),\n                          br(),\n                          br(),\n                          br()\n                 ),\n                 tabPanel(\"Contour Plot\",\n                          h4(\"Contour Plot\"),\n                          plotlyOutput(\"contourPlot\", height = \"700px\"),\n                 )\n               )\n             ),\n             \n           )\n  ),\n  \n  tabPanel(\"Transformation Demo\",\n           fluidPage(\n             h4(\"Transformation Matrix A (row-wise: a11, a12, a21, a22)\"),\n             h5(\"The original distribution is a bivariate normal with identity covariance matrix and is centered at 5 for both X and Y\"),\n             textInput(\"A_demo\", \"A:\", value = \"1, 0, 0, 1\"),\n             actionButton(\"resetA\", \"Reset A to Identity\", class = \"btn-secondary\"),\n             br(), br(),\n             helpText(\"Insert values with a , as the delimeter\"),\n             splitLayout(\n               cellWidths = c(\"50%\", \"50%\"),\n               plotlyOutput(\"originalPlot\"),\n               plotlyOutput(\"transformedPlot\")\n             ),\n             br(),\n             splitLayout(\n               cellWidths = c(\"50%\", \"50%\"),\n               plotlyOutput(\"original3DPlot\"),\n               plotlyOutput(\"transformed3DPlot\")\n             ),\n             br(),\n             h4(\"Σ' = AΣAᵀ\"),\n             verbatimTextOutput(\"transformedSigmaDemo\"),\n             h4(\"μ' = Aμ\"),\n             verbatimTextOutput(\"transformedMuDemo\"),\n             fluidRow(\n               column(12,\n                      h4(\"Interpretation\"),\n                      textOutput(\"interpretation2\")\n               )\n             ),\n             br(),\n             br(),\n             br()\n           )\n  ),\n  footer = tags$footer(\n    style = \"\n      position: fixed;\n      bottom: 0;\n      left: 0;\n      width: 100%;\n      background-color: #f8f9fa;\n      border-top: 1px solid #ddd;\n      text-align: center;\n      padding: 8px;\n      font-size: 12px;\n      color: #6c757d;\n      z-index: 1000;\n    \",\n    \"2025 Created by Shahriar Shams and Issey Sone\"\n  )\n)\n\n\n\nserver <- function(input, output) {\n  \n  # Helper Functions\n  \n  \n  \n  parseMatrix <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 4 || any(is.na(vals))) return(NULL)\n    matrix(vals, nrow = 2, byrow = TRUE)\n  }\n  \n  parseVector <- function(input_str) {\n    vals <- as.numeric(unlist(strsplit(input_str, \",\")))\n    if (length(vals) != 2 || any(is.na(vals))) return(NULL)\n    vals\n  }\n  \n \n  mu <- reactive({\n    parseVector(input$mu)\n  })\n  \n  sigma <- reactive({\n    sigma <- parseMatrix(input$sigma)\n  })\n  \n  \n  \n  axisRange <- reactive({\n    mu <- c(input$mu1, input$mu2)\n    sigma <- sigma()\n    \n    # Compute max std dev direction\n    max_sd <- sqrt(max(eigen(sigma)$values))\n    \n    lim <- 3 * max_sd + 1\n    \n    list(\n      x = c(mu[1] - lim, mu[1] + lim),\n      y = c(mu[2] - lim, mu[2] + lim),\n      z = c(0, 0.25) \n    )\n  })\n  A_demo_matrix <- reactiveVal(matrix(c(1, 0, 0, 1), nrow = 2))  # Default identity\n  \n  observeEvent(input$A_demo, {\n    parsed <- parseMatrix(input$A_demo)\n    if (is.null(parsed)) {\n      A_demo_matrix(NULL)\n    } else {\n      A_demo_matrix(parsed)\n    }\n  })\n  \n  observeEvent(input$resetA, {\n    updateTextInput(inputId = \"A_demo\", value = \"1, 0, 0, 1\", session = getDefaultReactiveDomain())\n  })\n  \n  \n  output$densityPlot <- renderPlotly({\n    mu <- mu()\n    if (is.null(mu)) return(NULL)\n    \n    sigma <- sigma()\n    if (is.null(sigma)) return(NULL)\n    \n    # check if the matrix is positive definite\n    if (!all(eigen(sigma)$values > 0)) {\n      return(plotly_empty(type = \"surface\") %>% \n               layout(title = \"Covariance matrix must be positive definite\"))\n    }\n    \n    x <- seq(mu[1] - 3 * sqrt(sigma[1, 1]), mu[1] + 3 * sqrt(sigma[1, 1]), length.out = 80)\n    y <- seq(mu[2] - 3 * sqrt(sigma[2, 2]), mu[2] + 3 * sqrt(sigma[2, 2]), length.out = 80)\n    grid <- expand.grid(x = x, y = y)\n    z <- matrix(dmvnorm(grid, mean = mu, sigma = sigma), nrow = length(x), byrow = TRUE)\n    \n    \n    ranges <- axisRange()\n    plot_ly(x = x, y = y, z = z) %>%\n      add_surface(contours = list(\n        z = list(show = TRUE, usecolormap = TRUE, highlightcolor = \"#ff0000\", project = list(z = TRUE))\n      )) %>%\n      layout(scene = list(\n        xaxis = list(title = \"X\", range = ranges$x),\n        yaxis = list(title = \"Y\", range = ranges$y),\n        zaxis = list(title = \"Density\", range = c(0, max(z, na.rm = TRUE) * 1.1)),\n        camera = list(eye = list(x = 1.8, y = 1.8, z = 1))\n      ))\n  })\n  \n  output$contourPlot <- renderPlotly({\n    mu <- mu()\n    sigma <- sigma()\n    \n    if (sigma[1, 2] != sigma[2, 1]) {\n      return(plotly_empty(type = \"surface\") %>% \n                layout(title = \"Covariance matrix must be Symmetric\"))\n    }\n    \n    if (is.null(mu) || is.null(sigma)) return(NULL)\n    if (!all(eigen(sigma)$values > 0)) {\n      return(plotly_empty(type = \"surface\") %>% \n               layout(title = \"Covariance matrix must be positive definite\"))\n    }\n    \n    # Sorted x and y sequences\n    x_seq <- sort(seq(mu[1] - 3 * sqrt(sigma[1, 1]), mu[1] + 3 * sqrt(sigma[1, 1]), length.out = 100))\n    y_seq <- sort(seq(mu[2] - 3 * sqrt(sigma[2, 2]), mu[2] + 3 * sqrt(sigma[2, 2]), length.out = 100))\n    \n    grid <- expand.grid(x = x_seq, y = y_seq)\n    z_vals <- matrix(mahalanobis(grid, center = mu, cov = sigma), nrow = length(x_seq), ncol = length(y_seq))\n    \n    probs <- c(0.95, 0.90, 0.80, 0.70, 0.60, 0.50)\n    labels <- paste0(probs * 100, \"%\")\n    levels_chi2 <- qchisq(probs, df = 2)\n    \n    contour_data <- do.call(rbind, lapply(seq_along(levels_chi2), function(i) {\n      level <- levels_chi2[i]\n      clines <- contourLines(x = x_seq, y = y_seq, z = z_vals, levels = level)\n      if (length(clines) == 0) return(NULL)\n      do.call(rbind, lapply(clines, function(cl) {\n        data.frame(x = cl$x, y = cl$y, level = labels[i])\n      }))\n    }))\n    \n    p <- ggplot(contour_data, aes(x = x, y = y, color = level)) +\n      geom_path(size = 1) +\n      scale_color_manual(\n        values = c(\"95%\" = \"blue4\",\n                   \"90%\" = \"blue3\",\n                   \"80%\" = \"dodgerblue3\",\n                   \"70%\" = \"deepskyblue2\",\n                   \"60%\" = \"lightskyblue\",\n                   \"50%\" = \"powderblue\"),\n        name = \"Confidence Level\"\n      ) +\n      coord_fixed() +\n      labs(title = \"2D Contour Plot\",\n           x = \"X\", y = \"Y\") +\n      theme_minimal()\n    \n    ggplotly(p)\n  })\n  \n  \n  \n  output$originalPlot <- renderPlotly({\n    mu <- c(5, 5)\n    sigma <- matrix(c(1, 0, 0, 1), nrow = 2)\n    \n    \n    x_seq <- sort(seq(mu[1] - 3 * sqrt(sigma[1, 1]), mu[1] + 3 * sqrt(sigma[1, 1]), length.out = 100))\n    y_seq <- sort(seq(mu[2] - 3 * sqrt(sigma[2, 2]), mu[2] + 3 * sqrt(sigma[2, 2]), length.out = 100))\n    \n    grid <- expand.grid(x = x_seq, y = y_seq)\n    z_vals <- matrix(mahalanobis(grid, center = mu, cov = sigma), nrow = length(x_seq), ncol = length(y_seq))\n    \n    probs <- c(0.95, 0.90, 0.80, 0.70, 0.60, 0.50)\n    labels <- paste0(probs * 100, \"%\")\n    levels_chi2 <- qchisq(probs, df = 2)\n    \n    contour_data <- do.call(rbind, lapply(seq_along(levels_chi2), function(i) {\n      level <- levels_chi2[i]\n      clines <- contourLines(x = x_seq, y = y_seq, z = z_vals, levels = level)\n      if (length(clines) == 0) return(NULL)\n      do.call(rbind, lapply(clines, function(cl) {\n        data.frame(x = cl$x, y = cl$y, level = labels[i])\n      }))\n    }))\n    \n    p <- ggplot(contour_data, aes(x = x, y = y, color = level)) +\n      geom_path(size = 1) +\n      scale_color_manual(\n        values = c(\"95%\" = \"blue4\",\n                   \"90%\" = \"blue3\",\n                   \"80%\" = \"dodgerblue3\",\n                   \"70%\" = \"deepskyblue2\",\n                   \"60%\" = \"lightskyblue\",\n                   \"50%\" = \"powderblue\"),\n        name = \"Confidence Level\"\n      ) +\n      coord_fixed() +\n      labs(title = \"Original Contour\",\n           x = \"X\", y = \"Y\") +\n      theme_minimal()\n    \n    ggplotly(p)\n  })\n  \n  output$transformedPlot <- renderPlotly({\n    \n    A <- A_demo_matrix()\n    if (is.null(A)) return(plotly_empty() %>% layout(title = \"Invalid A\"))\n    \n    mu <- c(5, 5)\n    sigma <- matrix(c(1, 0, 0, 1), nrow = 2)\n    \n    \n    transformed_mu <- A %*% as.matrix(mu)\n    \n    \n    transformed_sigma <- A %*% sigma %*% t(A)\n    \n    if (!all(eigen(transformed_sigma)$values > 0)) {\n      return(plotly_empty() %>% layout(title = \"A Σ Aᵀ is not positive definite\"))\n    }\n    \n    x_sd <- 3 * sqrt(transformed_sigma[1, 1])\n    y_sd <- 3 * sqrt(transformed_sigma[2, 2])\n    x_seq <- seq(transformed_mu[1] - x_sd, transformed_mu[1] + x_sd, length.out = 100)\n    y_seq <- seq(transformed_mu[2] - y_sd, transformed_mu[2] + y_sd, length.out = 100)\n    \n    \n    grid <- expand.grid(x = x_seq, y = y_seq)\n    z_vals <- matrix(mahalanobis(grid, center = transformed_mu, cov = transformed_sigma), nrow = length(x_seq), ncol = length(y_seq))\n    \n    probs <- c(0.95, 0.90, 0.80, 0.70, 0.60, 0.50)\n    labels <- paste0(probs * 100, \"%\")\n    levels_chi2 <- qchisq(probs, df = 2)\n    \n    contour_data <- do.call(rbind, lapply(seq_along(levels_chi2), function(i) {\n      level <- levels_chi2[i]\n      clines <- contourLines(x = x_seq, y = y_seq, z = z_vals, levels = level)\n      if (length(clines) == 0) return(NULL)\n      do.call(rbind, lapply(clines, function(cl) {\n        data.frame(x = cl$x, y = cl$y, level = labels[i])\n      }))\n    }))\n    \n    p <- ggplot(contour_data, aes(x = x, y = y, color = level)) +\n      geom_path(size = 1) +\n      scale_color_manual(\n        values = c(\"95%\" = \"blue4\",\n                   \"90%\" = \"blue3\",\n                   \"80%\" = \"dodgerblue3\",\n                   \"70%\" = \"deepskyblue2\",\n                   \"60%\" = \"lightskyblue\",\n                   \"50%\" = \"powderblue\"),\n        name = \"Confidence Level\"\n      ) +\n      coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +\n      labs(title = \"Transformed Contour\",\n           x = \"X\", y = \"Y\") +\n      theme_minimal()\n    \n    ggplotly(p)\n  })\n  \n  output$transformedSigmaDemo <- renderPrint({\n    A <- A_demo_matrix()\n    if (is.null(A)) return(\"Invalid A\")\n    sigma <- matrix(c(1, 0, 0, 1), nrow = 2)\n    A %*% sigma %*% t(A)\n  })\n  \n  output$transformedMuDemo <- renderPrint({\n    A <- A_demo_matrix()\n    if (is.null(A)) return (\"Invalid A\")\n    mu <- as.matrix(c(5, 5))\n    A %*% mu\n  })\n  \n  output$original3DPlot <- renderPlotly({\n    mu <- c(5, 5)\n    sigma <- matrix(c(1, 0, 0, 1), nrow = 2)\n    \n    x_seq <- seq(mu[1] - 3 * sqrt(sigma[1, 1]), mu[1] + 3 * sqrt(sigma[1, 1]), length.out = 80)\n    y_seq <- seq(mu[2] - 3 * sqrt(sigma[2, 2]), mu[2] + 3 * sqrt(sigma[2, 2]), length.out = 80)\n    grid <- expand.grid(x = x_seq, y = y_seq)\n    z_vals <- matrix(dmvnorm(grid, mean = mu, sigma = sigma), nrow = length(x_seq), byrow = TRUE)\n    \n    plot_ly(x = x_seq, y = y_seq, z = z_vals) %>%\n      add_surface(colorscale = \"Viridis\") %>%\n      layout(title = \"Original 3D Density\",\n             scene = list(\n               xaxis = list(title = \"X\"),\n               yaxis = list(title = \"Y\"),\n               zaxis = list(title = \"Density\")\n             ))\n  })\n  \n  output$transformed3DPlot <- renderPlotly({\n    A <- A_demo_matrix()\n    mu <- c(5, 5)\n    \n    sigma <- matrix(c(100, 1, 1, 100), nrow = 2)\n    transformed_sigma <- A %*% sigma %*% t(A)\n    transformed_mu <- A %*% as.matrix(mu)\n    \n    if (!all(eigen(transformed_sigma)$values > 0)) {\n      return(plotly_empty() %>% layout(title = \"A Σ Aᵀ is not positive definite\"))\n    }\n    \n    x_seq <- seq(transformed_mu[1] - 3 * sqrt(transformed_sigma[1, 1]),\n                 transformed_mu[1] + 3 * sqrt(transformed_sigma[1, 1]), length.out = 80)\n    y_seq <- seq(transformed_mu[2] - 3 * sqrt(transformed_sigma[2, 2]),\n                 transformed_mu[2] + 3 * sqrt(transformed_sigma[2, 2]), length.out = 80)\n    grid <- expand.grid(x = x_seq, y = y_seq)\n    z_vals <- matrix(dmvnorm(grid, mean = transformed_mu, sigma = transformed_sigma), nrow = length(x_seq), byrow = TRUE)\n    \n    plot_ly(x = x_seq, y = y_seq, z = z_vals) %>%\n      add_surface(colorscale = \"Viridis\") %>%\n      layout(title = \"Transformed 3D Density\",\n             scene = list(\n               xaxis = list(title = \"X\"),\n               yaxis = list(title = \"Y\"),\n               zaxis = list(title = \"Density\")\n             ))\n  })\n  \n  # Interpretations\n  output$interpretation1 <- renderText({\n    \"Adding a positive covariance term will tilt the distribution where the two variables tend to increase together creating an upward-sloping shape.\n     Likewise, adding a negative covariance term tilts the distribution in the opposite direction, where when one variable increases the other decreases.\n    Click on the 'Contour Plot' tab to see the direction of the shape more clearly.\"\n  })\n  \n  output$interpretation2 <- renderText({\n    \"Multiplying a Standard bivariate normal distribution by a 2x2 tranformation matrix linearly stretches, rotates, and skews the distribution. Off-diagonal elements\n    in the matrix will introduce covariance between the variables.\"\n  })\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"}]
